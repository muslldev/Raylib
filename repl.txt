#include <fstream>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <limits>
#include <vector>
#include <sstream>
#include <queue>
#include <unordered_map>
#include <stack>

struct Node
{
    long id;
    double x;
    double y;

    Node(long id, double x, double y) : id(id), x(x), y(y) {}
};

struct Edge
{
    long u;
    long v;
    double dist; // distance between u-v

    Edge(long u, long v, double dist) : u(u), v(v), dist(dist) {}
};

double euclidean_dist(double x1, double y1, double x2, double y2)
{
    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}

std::vector<Node> read_nodes(std::string path)
{
    std::fstream csv(path);

    // skip csv header
    std::string header;
    std::getline(csv, header);

    std::vector<Node> nodes;
    // read data
    for (std::string line; std::getline(csv, line);)
    {
        try
        {
            std::stringstream lineStream(line);
            std::string cell;

            std::getline(lineStream, cell, ',');
            long id = std::stoll(cell);

            std::getline(lineStream, cell, ',');
            double x = std::stod(cell);

            std::getline(lineStream, cell, ',');
            double y = std::stod(cell);
            nodes.emplace_back(id, x, y);
        }
        catch (const std::invalid_argument &ia)
        {
            std::cerr << "Invalid argument: " << ia.what() << '\n';
            std::cerr << "line == " << line << '\n';
        }
    }

    return nodes;
}

std::vector<Edge> read_edges(std::string path)
{
    std::fstream csv(path);

    std::string header;
    std::getline(csv, header);

    std::vector<Edge> edges;

    for (std::string line; std::getline(csv, line);)
    {
        try
        {
            std::stringstream lineStream(line);
            std::string cell;

            std::getline(lineStream, cell, ',');
            long u = std::stoll(cell);

            std::getline(lineStream, cell, ',');
            long v = std::stoll(cell);

            std::getline(lineStream, cell, ',');
            double dist = std::stod(cell);

            edges.emplace_back(u, v, dist);
        }
        catch (const std::invalid_argument &ia)
        {
            std::cerr << "Invalid argument: " << ia.what() << '\n';
            std::cerr << "line == " << line << '\n';
        }
    }

    return edges;
}

std::unordered_map<long, long> astar(const std::vector<Node> &nodes, const std::vector<Edge> &edges, long start, long target, std::unordered_map<long, double> &dist_map)
{
    std::unordered_map<long, bool> visited_map;
    std::unordered_map<long, long> prev_map;
    for (const auto &node : nodes)
    {
        visited_map[node.id] = false;
        prev_map[node.id] = -1;
    }

    dist_map[start] = 0;

    auto heuristic = [&nodes](long u, long v)
    {
        const auto &node_u = nodes[u - 1];
        const auto &node_v = nodes[v - 1];
        return euclidean_dist(node_u.x, node_u.y, node_v.x, node_v.y);
    };

    auto compare = [&dist_map, &heuristic, target](const std::pair<double, long> &a, const std::pair<double, long> &b)
    {
        return (dist_map[a.second] + heuristic(a.second, target)) > (dist_map[b.second] + heuristic(b.second, target));
    };

    std::priority_queue<std::pair<double, long>, std::vector<std::pair<double, long>>, decltype(compare)> pq(compare);
    pq.push(std::make_pair(0, start));

    while (!pq.empty())
    {
        long u = pq.top().second;
        pq.pop();

        if (visited_map[u])
            continue;

        visited_map[u] = true;

        for (const Edge &edge : edges)
        {
            if (edge.u == u)
            {
                long v = edge.v;
                double alt = dist_map[u] + edge.dist;
                if (alt < dist_map[v])
                {
                    dist_map[v] = alt;
                    prev_map[v] = u;
                    pq.push(std::make_pair(dist_map[v], v));
                }
            }
        }
    }

    return prev_map;
}

void print_shortest_paths(const std::vector<Node> &nodes, std::unordered_map<long, double> &dist, std::unordered_map<long, long> &prev, long start, long goal)
{
    if (dist[goal] == std::numeric_limits<double>::infinity()) {
        std::cout << "No path from node " << start << " to node " << goal << std::endl;
        return;
    }

    std::vector<long> path;
    long current = goal;
    while (current != -1)
    {
        path.push_back(current);
        current = prev[current];
    }

    std::cout << "Shortest path from node " << start << " to node " << goal << ": ";
    for (auto it = path.rbegin(); it != path.rend(); ++it)
    {
        std::cout << *it << " ";
    }
    std::cout << "with distance " << dist[goal] << std::endl;
}




int main()
{
    auto nodes = read_nodes("omsk/nodes.csv");
    auto edges = read_edges("omsk/edges.csv");

    std::unordered_map<long, std::size_t> node_id_to_pos;
    for (std::size_t i = 1; i < nodes.size() + 1; i++)
    {
        const auto &node = nodes[i - 1];
        node_id_to_pos[node.id] = i;
    }

    std::cout << nodes.size() << std::endl;
    std::cout << edges.size() << std::endl;
    


    long start_id = nodes[0].id;
    long goal_id = nodes.back().id;
   // std::cout << "Starting from node ID: " << start_id << " to reach node ID: " << goal_id << std::endl;

    std::unordered_map<long, double> dist;
    for (const auto &node : nodes)
    {
        dist[node.id] = std::numeric_limits<double>::infinity();
    }

    for (auto &edge : edges)
    {
        const auto &u = nodes[edge.u - 1];
        const auto &v = nodes[edge.v - 1];

        edge.dist = euclidean_dist(u.x, u.y, v.x, v.y);
    }

    std::unordered_map<long, long> prev = astar(nodes, edges, start_id, goal_id, dist);
    print_shortest_paths(nodes, dist, prev, start_id, goal_id);

    return 0;
}

